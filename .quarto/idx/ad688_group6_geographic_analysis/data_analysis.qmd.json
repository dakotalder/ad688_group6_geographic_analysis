{"title":"Data Analysis","markdown":{"yaml":{"title":"Data Analysis","subtitle":"Comprehensive Data Cleaning & Exploratory Analysis of Geographic Data","author":["Dakota Alder","Julio Garcia"],"format":{"html":{"toc":true,"number-sections":true,"df-print":"paged"}}},"headingText":"Load and Preview LightCast Data","containsRefs":false,"markdown":"\n\n\n```{python}\nfrom pyspark.sql import SparkSession\n\n\n# Start a Spark session\nspark = SparkSession.builder.appName(\"JobPostingsAnalysis\").getOrCreate()\n\n# Load the CSV file into a Spark DataFrame\ndf = spark.read.option(\"header\", \"true\").option(\"inferSchema\", \"true\").option(\"multiLine\",\"true\").option(\"escape\", \"\\\"\").csv(\"../data/lightcast_job_postings.csv\")\n\n\n\n```\n\n# Drop unnecessary columns\n\nRedundant or irrelevant columns are dropped here.\n\nNAICS and SOC levels are removed because each job is already described by its most detailed (and most general) industry and occupation classification (NAICS_2022_6_NAME and SOC_6_NAME).\n\nTimestamps and system variables (like LAST_UPDATED_TIMESTAMP) are not meaningful.\n\nSimplifying the dataset this way speeds up our processing and makes the whole dataframe look more clean and user-friendly.\n\n\n\n```{python}\nimport pandas as pd\nfrom pyspark.sql.functions import when, col\n\n#Clean Data to convert to Pandas\ncolumns_to_drop = [\"ID\", \"BODY\", \"URL\", \"ACTIVE_URLS\", \"DUPLICATES\", \"LAST_UPDATED_TIMESTAMP\",\n    \"NAICS2\", \"NAICS3\", \"NAICS4\", \"NAICS5\", \"NAICS6\",\n    \"SOC_2\", \"SOC_3\", \"SOC_4\", \"SOC_5\", \"LAST_UPDATED_DATE\", \"LAST_UPDATED_TIMESTAMP\", \"EXPIRED\", \"SOURCE_TYPES\", \"SOURCES\", \"ACTIVE_SOURCES_INFO\", \"MODELED_EXPIRED\", \"MODELED_DURATION\", \"NAICS2_NAME\", \"NAICS3_NAME\", \"NAICS4_NAME\", \"NAICS5_NAME\", \"NAICS6_NAME\",\n    \"SOC_2_NAME\", \"SOC_3_NAME\", \"SOC_4_NAME\", \"SOC_5_NAME\", \"EDUCATION_LEVELS\", \"MIN_EDULEVELS\"\n    \n]\ncleaned_data = df.drop(*columns_to_drop)\n\ncleaned_data = cleaned_data.withColumn(\n    \"REMOTE_TYPE_NAME\",\n    when(col(\"REMOTE_TYPE_NAME\") == \"Remote\", \"Remote\")\n    .when(col(\"REMOTE_TYPE_NAME\") == \"Hybrid Remote\", \"Hybrid\")\n    .when(col(\"REMOTE_TYPE_NAME\") == \"[None]\", \"On-site\")\n    .when(col(\"REMOTE_TYPE_NAME\").isNull(), \"On-site\")\n    .when(col(\"REMOTE_TYPE_NAME\") == \"Not Remote\", \"On-site\")\n    .otherwise(col(\"REMOTE_TYPE_NAME\"))\n)\n\ncleaned_data = cleaned_data.withColumn(\n    \"EMPLOYMENT_TYPE_NAME\",\n    when(col(\"EMPLOYMENT_TYPE_NAME\") == \"Part-time / full-time\", \"Flexible\")\n    .when(col(\"EMPLOYMENT_TYPE_NAME\").isNull(), \"Full-Time\")\n    .when(col(\"EMPLOYMENT_TYPE_NAME\") == \"Part-time (â‰¤ 32 hours)\", \"Part-Time\")\n    .when(col(\"EMPLOYMENT_TYPE_NAME\") == \"Full-time (> 32 hours)\", \"Full-Time\")\n    .otherwise(col(\"EMPLOYMENT_TYPE_NAME\")) \n)\n\ncleaned_data = cleaned_data.filter(col(\"NAICS_2022_2_NAME\") != \"Unclassified Industry\")\n\nmedian_salary = cleaned_data.approxQuantile(\"SALARY\", [0.5], 0.01)[0]\ncleaned_data = cleaned_data.withColumn(\n    \"SALARY\",\n    when(col(\"SALARY\").isNull(), median_salary).otherwise(col(\"SALARY\"))\n)\n\n\nclean_pdf = cleaned_data.toPandas()\n\n\n\n```\n\n# Handle Missing Values\n\nWe also cleaned categorical values\n\nMissing categorical data (like City, Company, State) were replaced with \"Unknown\" so that there is data in all rows.\nDuplicates were also dropped to not skew the analysis.\nSalary missing values were replaced with the median salary.\nRemote Type Name and Employment type were simplified into smaller groupings.\n\n```{python}\n#| echo: true\n#| eval: true\nimport missingno as msno\nimport matplotlib.pyplot as plt\n\n# Visualize missing data\nmsno.heatmap(clean_pdf)\nplt.title(\"Missing Values Heatmap\")\nplt.show()\n\nfill_cols = [\"CITY_NAME\", \"CITY\", \"LOCATION\", \"STATE\", \"STATE_NAME\", \"COMPANY\", \"COMPANY_NAME\"]\nclean_pdf[fill_cols] = clean_pdf[fill_cols].fillna(\"Unknown\")\n\nclean_pdf = clean_pdf.drop_duplicates(subset=[\"TITLE\", \"COMPANY\", \"LOCATION\", \"POSTED\"], keep=\"first\")\n\nclean_pdf.dropna(thresh=len(clean_pdf)*0.5, axis=1, inplace=True)\n\n\n```\n\n# Helper Columns for classifying AI and Posted Dates\n\nWe created columns to classify what job titles may be affected by AI vs Non-AI Job Titles\nWe created a column for the month that the job was posted in order to create growth data\n```{python}\n#New Column to Classify AI Jobs and Add Month of Posting Date\n\n\nai_keywords = [\n    \"AI\", \"Machine Learning\", \"Data Scientist\", \"Data Analyst\", \"ML\", \n    \"Artificial Intelligence\", \"Deep Learning\", \"NLP\", \"Predictive Analytics\"\n]\n\n#Function to classify AI vs Non-AI Jobs\ndef classify_ai(title):\n    title_lower = str(title).lower()\n    for keyword in ai_keywords:\n        if keyword.lower() in title_lower:\n            return \"AI\"\n    return \"Non-AI\"\n\nclean_pdf[\"AI_JOB\"] = clean_pdf[\"TITLE_RAW\"].apply(classify_ai)\n\nclean_pdf[\"POSTED\"] = pd.to_datetime(clean_pdf[\"POSTED\"], errors=\"coerce\")\nclean_pdf[\"POSTED_MONTH\"] = clean_pdf[\"POSTED\"].dt.month\n\n#clean_pdf.head(25)\n```\n\n# City and State Analysis by AI vs Non-AI Jobs\n\nKey Insights: \n\n```{python}\n#Question 1 Visualization: Which Cities or States have the highest job growth for AI vs Non-AI\n\ncount_by_month_state = (\n  clean_pdf.groupby([\"STATE_NAME\", \"POSTED_MONTH\", \"AI_JOB\"])\n  .size()\n  .reset_index(name=\"count\")\n)\n\ncount_by_month_city = (\n  clean_pdf.groupby([\"CITY_NAME\", \"POSTED_MONTH\", \"AI_JOB\"])\n  .size()\n  .reset_index(name=\"count\")\n)\n\n#Measure job growth by State and then by city\ncount_by_month_state = count_by_month_state.sort_values([\"STATE_NAME\", \"AI_JOB\", \"POSTED_MONTH\"])\ncount_by_month_state[\"GROWTH\"] = (\n  count_by_month_state\n  .groupby([\"STATE_NAME\", \"AI_JOB\"])[\"count\"]\n  .pct_change() * 100\n)\n\ncount_by_month_city = count_by_month_city.sort_values([\"CITY_NAME\", \"AI_JOB\", \"POSTED_MONTH\"])\ncount_by_month_city[\"GROWTH\"] = (\n  count_by_month_city\n  .groupby([\"CITY_NAME\", \"AI_JOB\"])[\"count\"]\n  .pct_change() * 100\n)\n\navg_growth_state = (\n    count_by_month_state.groupby([\"STATE_NAME\", \"AI_JOB\"])[\"GROWTH\"]\n    .mean()\n    .reset_index()\n    .dropna()\n    .sort_values(\"GROWTH\", ascending=False)\n)\n\navg_growth_city = (\n    count_by_month_city.groupby([\"CITY_NAME\", \"AI_JOB\"])[\"GROWTH\"]\n    .mean()\n    .reset_index()\n    .dropna()\n    .sort_values(\"GROWTH\", ascending=False)\n)\n\nprint(\"Top 10 States by AI Job Growth:\")\nprint(avg_growth_state[avg_growth_state[\"AI_JOB\"] == \"AI\"].head(10))\n\nprint(\"\\nTop 10 States by Non-AI Job Growth:\")\nprint(avg_growth_state[avg_growth_state[\"AI_JOB\"] == \"Non-AI\"].head(10))\n\nprint(\"Top 10 Cities by AI Job Growth:\")\nprint(avg_growth_city[avg_growth_city[\"AI_JOB\"] == \"AI\"].head(10))\n\nprint(\"\\nTop 10 Cities by Non-AI Job Growth:\")\nprint(avg_growth_city[avg_growth_city[\"AI_JOB\"] == \"Non-AI\"].head(10))\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nstate_visual = avg_growth_state.groupby(\"AI_JOB\").head(10)\n\nplt.figure(figsize=(10,6))\nax_state = sns.barplot(data=state_visual, y=\"STATE_NAME\", x=\"GROWTH\", hue=\"AI_JOB\", palette=\"viridis\")\nplt.title(\"Top 10 States by Average Monthly Job Growth: AI vs Non-AI\")\nplt.xlabel(\"Average Monthly Growth (%)\")\nplt.ylabel(\"State\")\n\nfor container in ax_state.containers:\n  ax_state.bar_label(container, fmt=\"%.1f%%\", label_type=\"edge\", padding=3, fontsize=9)\n\nplt.tight_layout()\nplt.savefig(\"../ad688_group6_geographic_analysis/images/top10state.png\", dpi=300)\nplt.show()\n\ncity_visual = avg_growth_city.groupby(\"AI_JOB\").head(10)\n\nplt.figure(figsize=(10,6))\nax_city = sns.barplot(data=city_visual, y=\"CITY_NAME\", x=\"GROWTH\", hue=\"AI_JOB\", palette=\"viridis\")\nplt.title(\"Top 10 Cities by Average Monthly Job Growth: AI vs Non-AI\")\nplt.xlabel(\"Average Monthly Growth (%)\")\nplt.ylabel(\"City\")\n\nfor container in ax_city.containers:\n  ax_city.bar_label(container, fmt=\"%.1f%%\", label_type=\"edge\", padding=3, fontsize=9)\n\nplt.tight_layout()\nplt.savefig(\"../ad688_group6_geographic_analysis/images/top10city.png\", dpi=300)\nplt.show()\n\n\n```\n\n## Key Insights\n\nThe analysis shows that AI jobs postings are increasing at a higher rate than Non-AI jobs, and that is especially true in Hawaii, Wyoming, Montana, and Mississippi. However, there seems to be no AI Job growth in multiple states, and an increase in Non-AI jobs in those same states, suggesting that AI isn't quite yet displacing jobs. In fact, there are only a select few states where AI Jobs are increasing, most of the 50 states have an increase in Non-AI jobs.\n\n# Remote Job Growth by Industry\n\nKey Insights: \n```{python}\n#Question 2: Are remote jobs increasing or decreasing across industries?\n\nremote_only = clean_pdf[clean_pdf[\"REMOTE_TYPE_NAME\"] == \"Remote\"]\n\nremote_growth = (\n  remote_only.groupby([\"NAICS_2022_2_NAME\", \"POSTED_MONTH\"])\n  .size()\n  .reset_index(name=\"count\")\n)\n\n\ntop_5_industries = (\n  remote_only[\"NAICS_2022_2_NAME\"]\n  .value_counts()\n  .head(5)\n  .index\n)\n\ntop_remote_growth = remote_growth[remote_growth[\"NAICS_2022_2_NAME\"].isin(top_5_industries)]\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(12, 7))\nsns.lineplot(\n    data=top_remote_growth,\n    x=\"POSTED_MONTH\",\n    y=\"count\",\n    hue=\"NAICS_2022_2_NAME\"\n)\nplt.title(\"Remote Job Trends Across Top 10 Industries\")\nplt.xlabel(\"Month\")\nplt.ylabel(\"Number of Job Postings\")\nplt.legend(title=\"Industry\", bbox_to_anchor=(1.05, 1), loc='upper left')\nplt.tight_layout()\nplt.savefig(\"../ad688_group6_geographic_analysis/images/remoteindustries.png\", dpi=300)\nplt.show()\n\n```\n\n## Key Insights\n\nWhen looking at the growth of Remote jobs by industry, we can see that there is an increase in remote jobs in the Finance and Insurance Industries, the Information Industries, and the Administrative and Support and Waste Management and Remediation Services Industries. This seems to suggest that more tech heavy industries can support and are seeing growth in remote positions, but industries like Professional, Scientific, and Technical Services are actually seeing a decline in remote work. These industries might have job titles that require in person work and assistance, which would lead to on-site.\n\n# Tech-Hubs vs emerging Markets\n\nKey Insights: \n```{python}\n#Question #3: Do Tech hubs (Silicon Valley, Austin, Boston) still dominate hiring, or are other locations emerging?\n\ntech_hubs = [\"Austin-Round Rock-Georgetown, TX\", \"Boston-Cambridge-Newton, MA-NH\",\"Los Angeles-Long Beach-Anaheim, CA\",\"San Diego-Chula Vista-Carlsbad, CA\",\"San Francisco-Oakland-Berkeley, CA\",\"San Jose-Sunnyvale-Santa Clara, CA\",\"Seattle-Tacoma-Bellevue, WA\"]\n\n# Create a column classifying if the city is a tech hub\nclean_pdf[\"TECH_HUB\"] = clean_pdf[\"MSA_NAME\"].apply(\n    lambda x: \"Tech Hub\" if x in tech_hubs else \"Other\"\n)\n\n#Count number of postings by Tech Hub\ntech_hub_counts = (\n  clean_pdf.groupby(\"MSA_NAME\")\n  .size()\n  .reset_index(name=\"count\")\n  .sort_values(\"count\", ascending=False)\n)\n\n# Merge to add TECH_HUB classification to each MSA\ntech_hub_counts = tech_hub_counts.merge(\n    clean_pdf[[\"MSA_NAME\", \"TECH_HUB\"]].drop_duplicates(),\n    on=\"MSA_NAME\",\n    how=\"left\"\n)\n\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nplt.figure(figsize=(18, 15))\nsns.barplot(\n    data=tech_hub_counts.head(15),\n    x=\"MSA_NAME\",\n    y=\"count\",\n    hue=\"TECH_HUB\",\n    palette=\"viridis\"\n)\nplt.title(\"Top 15 Metro Areas by Count of Job Postings\")\nplt.xlabel(\"Tech Hub\")\nplt.ylabel(\"Number of Job Postings\")\nplt.xticks(rotation=45, ha=\"right\")\n\n# Add labels on top of bars\n#for i, row in tech_hub_counts.head(15).iterrows():\n#    plt.text(row[\"count\"] + 100, i, f\"{row['count']:,}\", va=\"center\", fontsize=10)\n\n#plt.tight_layout()\nplt.savefig(\"../ad688_group6_geographic_analysis/images/top15techhubs.png\", dpi=300)\nplt.show()\n\n```\n![Top 15 Tech Hubs](../ad688_group6_geographic_analysis/images/top15techhubs.png){fig-align=\"center\" width=\"80%\"}\n\n## Key Insights\n\nThis plot is showing the concentration of job postings in each of the top 15 metro areas, which is interesting because the top 5 are actually not part of the tech hubs list that we created. Number 6, 7, 8, 11, and 15 are tech hubs, but this goes to show that a job seeker does not need to be in a tech hub for job searching. There are plenty of high population, metro areas that will have plenty of jobs. We would like to go further and look at industry and AI jobs as well, which is found in the next plot.\n\n# A Comparison of the Urban and Rural Job Market in relation to AI Careers\n\nKey Insights: \n```{python}\n# Question 4: How do Urban vs. Rural Job markets differ for AI and non-AI careers?\n\n# Classify as 'Urban' if MSA_NAME is present, else 'Rural'\nclean_pdf[\"URBAN_RURAL\"] = clean_pdf[\"MSA_NAME\"].apply(lambda x: \"Urban\" if pd.notnull(x) else \"Rural\")\n\n# Group data by month, urban/rural, and AI vs Non-AI\nurban_rural_jobs = (\n    clean_pdf.groupby([\"URBAN_RURAL\", \"AI_JOB\"])\n    .size()\n    .reset_index(name=\"count\")\n)\n\n#Calculate percentages\nurban_rural_jobs[\"PERCENT\"] = (\n  urban_rural_jobs.groupby(\"URBAN_RURAL\")[\"count\"]\n  .apply(lambda x: 100 * x / x.sum())\n  .values\n)\n\n#Convert Percentage into 2 decimal places\n\nurban_rural_jobs[\"PERCENT\"] = urban_rural_jobs[\"PERCENT\"].apply(lambda x:f\"{x:.2f}%\")\n\n# Visualization\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(12, 6))\nax_urban = sns.barplot(\n    data=urban_rural_jobs,\n    x=\"URBAN_RURAL\",\n    y=\"count\",\n    hue=\"AI_JOB\",\n    palette=\"viridis\"\n)\n\nplt.title(\"AI vs Non-AI Jobs in Urban vs Rural Areas\")\nplt.xlabel(\"Urban or Rural\")\nplt.ylabel(\"Number of Job Postings\")\nplt.legend(title=\"Job Type\")\n\nfor container in ax_urban.containers:\n  ax_urban.bar_label(container, fmt=\"%d\", label_type=\"edge\", padding=3, fontsize=11)\nplt.tight_layout()\nplt.savefig(\"../ad688_group6_geographic_analysis/images/urbanai.png\", dpi=300)\nplt.show()\n\nfig, ax = plt.subplots(figsize=(7,4))  \nax.axis('off') \n\ntable = ax.table(\n    cellText=urban_rural_jobs.values,\n    colLabels=urban_rural_jobs.columns,\n    cellLoc='center',\n    loc='center',\n    colColours=[\"#0b2545\"]*len(urban_rural_jobs.columns),  # Dark blue header\n    colWidths=[0.3]*len(urban_rural_jobs.columns)\n)\n\ntable.auto_set_font_size(False)\ntable.set_fontsize(12)\ntable.scale(1.2, 1.2) \n\nfor key, cell in table.get_celld().items():\n  if key[0] == 0:\n    cell.set_fontsize(14)\n    cell.set_text_props(color='white')\n    cell.set_facecolor('#0b2545')\n\nplt.show()\n\n```\n\n## Key Insights\n\nThis plot shows that the percentage of AI Jobs in Urban areas is actually almost exactly equal to the percentage of AI Jobs in rural areas. Even though the count of these types of jobs are much different, there are opportunities for job seekers to find AI related jobs at the same rate in rural areas compared to urban areas.","srcMarkdownNoYaml":"\n\n# Load and Preview LightCast Data\n\n```{python}\nfrom pyspark.sql import SparkSession\n\n\n# Start a Spark session\nspark = SparkSession.builder.appName(\"JobPostingsAnalysis\").getOrCreate()\n\n# Load the CSV file into a Spark DataFrame\ndf = spark.read.option(\"header\", \"true\").option(\"inferSchema\", \"true\").option(\"multiLine\",\"true\").option(\"escape\", \"\\\"\").csv(\"../data/lightcast_job_postings.csv\")\n\n\n\n```\n\n# Drop unnecessary columns\n\nRedundant or irrelevant columns are dropped here.\n\nNAICS and SOC levels are removed because each job is already described by its most detailed (and most general) industry and occupation classification (NAICS_2022_6_NAME and SOC_6_NAME).\n\nTimestamps and system variables (like LAST_UPDATED_TIMESTAMP) are not meaningful.\n\nSimplifying the dataset this way speeds up our processing and makes the whole dataframe look more clean and user-friendly.\n\n\n\n```{python}\nimport pandas as pd\nfrom pyspark.sql.functions import when, col\n\n#Clean Data to convert to Pandas\ncolumns_to_drop = [\"ID\", \"BODY\", \"URL\", \"ACTIVE_URLS\", \"DUPLICATES\", \"LAST_UPDATED_TIMESTAMP\",\n    \"NAICS2\", \"NAICS3\", \"NAICS4\", \"NAICS5\", \"NAICS6\",\n    \"SOC_2\", \"SOC_3\", \"SOC_4\", \"SOC_5\", \"LAST_UPDATED_DATE\", \"LAST_UPDATED_TIMESTAMP\", \"EXPIRED\", \"SOURCE_TYPES\", \"SOURCES\", \"ACTIVE_SOURCES_INFO\", \"MODELED_EXPIRED\", \"MODELED_DURATION\", \"NAICS2_NAME\", \"NAICS3_NAME\", \"NAICS4_NAME\", \"NAICS5_NAME\", \"NAICS6_NAME\",\n    \"SOC_2_NAME\", \"SOC_3_NAME\", \"SOC_4_NAME\", \"SOC_5_NAME\", \"EDUCATION_LEVELS\", \"MIN_EDULEVELS\"\n    \n]\ncleaned_data = df.drop(*columns_to_drop)\n\ncleaned_data = cleaned_data.withColumn(\n    \"REMOTE_TYPE_NAME\",\n    when(col(\"REMOTE_TYPE_NAME\") == \"Remote\", \"Remote\")\n    .when(col(\"REMOTE_TYPE_NAME\") == \"Hybrid Remote\", \"Hybrid\")\n    .when(col(\"REMOTE_TYPE_NAME\") == \"[None]\", \"On-site\")\n    .when(col(\"REMOTE_TYPE_NAME\").isNull(), \"On-site\")\n    .when(col(\"REMOTE_TYPE_NAME\") == \"Not Remote\", \"On-site\")\n    .otherwise(col(\"REMOTE_TYPE_NAME\"))\n)\n\ncleaned_data = cleaned_data.withColumn(\n    \"EMPLOYMENT_TYPE_NAME\",\n    when(col(\"EMPLOYMENT_TYPE_NAME\") == \"Part-time / full-time\", \"Flexible\")\n    .when(col(\"EMPLOYMENT_TYPE_NAME\").isNull(), \"Full-Time\")\n    .when(col(\"EMPLOYMENT_TYPE_NAME\") == \"Part-time (â‰¤ 32 hours)\", \"Part-Time\")\n    .when(col(\"EMPLOYMENT_TYPE_NAME\") == \"Full-time (> 32 hours)\", \"Full-Time\")\n    .otherwise(col(\"EMPLOYMENT_TYPE_NAME\")) \n)\n\ncleaned_data = cleaned_data.filter(col(\"NAICS_2022_2_NAME\") != \"Unclassified Industry\")\n\nmedian_salary = cleaned_data.approxQuantile(\"SALARY\", [0.5], 0.01)[0]\ncleaned_data = cleaned_data.withColumn(\n    \"SALARY\",\n    when(col(\"SALARY\").isNull(), median_salary).otherwise(col(\"SALARY\"))\n)\n\n\nclean_pdf = cleaned_data.toPandas()\n\n\n\n```\n\n# Handle Missing Values\n\nWe also cleaned categorical values\n\nMissing categorical data (like City, Company, State) were replaced with \"Unknown\" so that there is data in all rows.\nDuplicates were also dropped to not skew the analysis.\nSalary missing values were replaced with the median salary.\nRemote Type Name and Employment type were simplified into smaller groupings.\n\n```{python}\n#| echo: true\n#| eval: true\nimport missingno as msno\nimport matplotlib.pyplot as plt\n\n# Visualize missing data\nmsno.heatmap(clean_pdf)\nplt.title(\"Missing Values Heatmap\")\nplt.show()\n\nfill_cols = [\"CITY_NAME\", \"CITY\", \"LOCATION\", \"STATE\", \"STATE_NAME\", \"COMPANY\", \"COMPANY_NAME\"]\nclean_pdf[fill_cols] = clean_pdf[fill_cols].fillna(\"Unknown\")\n\nclean_pdf = clean_pdf.drop_duplicates(subset=[\"TITLE\", \"COMPANY\", \"LOCATION\", \"POSTED\"], keep=\"first\")\n\nclean_pdf.dropna(thresh=len(clean_pdf)*0.5, axis=1, inplace=True)\n\n\n```\n\n# Helper Columns for classifying AI and Posted Dates\n\nWe created columns to classify what job titles may be affected by AI vs Non-AI Job Titles\nWe created a column for the month that the job was posted in order to create growth data\n```{python}\n#New Column to Classify AI Jobs and Add Month of Posting Date\n\n\nai_keywords = [\n    \"AI\", \"Machine Learning\", \"Data Scientist\", \"Data Analyst\", \"ML\", \n    \"Artificial Intelligence\", \"Deep Learning\", \"NLP\", \"Predictive Analytics\"\n]\n\n#Function to classify AI vs Non-AI Jobs\ndef classify_ai(title):\n    title_lower = str(title).lower()\n    for keyword in ai_keywords:\n        if keyword.lower() in title_lower:\n            return \"AI\"\n    return \"Non-AI\"\n\nclean_pdf[\"AI_JOB\"] = clean_pdf[\"TITLE_RAW\"].apply(classify_ai)\n\nclean_pdf[\"POSTED\"] = pd.to_datetime(clean_pdf[\"POSTED\"], errors=\"coerce\")\nclean_pdf[\"POSTED_MONTH\"] = clean_pdf[\"POSTED\"].dt.month\n\n#clean_pdf.head(25)\n```\n\n# City and State Analysis by AI vs Non-AI Jobs\n\nKey Insights: \n\n```{python}\n#Question 1 Visualization: Which Cities or States have the highest job growth for AI vs Non-AI\n\ncount_by_month_state = (\n  clean_pdf.groupby([\"STATE_NAME\", \"POSTED_MONTH\", \"AI_JOB\"])\n  .size()\n  .reset_index(name=\"count\")\n)\n\ncount_by_month_city = (\n  clean_pdf.groupby([\"CITY_NAME\", \"POSTED_MONTH\", \"AI_JOB\"])\n  .size()\n  .reset_index(name=\"count\")\n)\n\n#Measure job growth by State and then by city\ncount_by_month_state = count_by_month_state.sort_values([\"STATE_NAME\", \"AI_JOB\", \"POSTED_MONTH\"])\ncount_by_month_state[\"GROWTH\"] = (\n  count_by_month_state\n  .groupby([\"STATE_NAME\", \"AI_JOB\"])[\"count\"]\n  .pct_change() * 100\n)\n\ncount_by_month_city = count_by_month_city.sort_values([\"CITY_NAME\", \"AI_JOB\", \"POSTED_MONTH\"])\ncount_by_month_city[\"GROWTH\"] = (\n  count_by_month_city\n  .groupby([\"CITY_NAME\", \"AI_JOB\"])[\"count\"]\n  .pct_change() * 100\n)\n\navg_growth_state = (\n    count_by_month_state.groupby([\"STATE_NAME\", \"AI_JOB\"])[\"GROWTH\"]\n    .mean()\n    .reset_index()\n    .dropna()\n    .sort_values(\"GROWTH\", ascending=False)\n)\n\navg_growth_city = (\n    count_by_month_city.groupby([\"CITY_NAME\", \"AI_JOB\"])[\"GROWTH\"]\n    .mean()\n    .reset_index()\n    .dropna()\n    .sort_values(\"GROWTH\", ascending=False)\n)\n\nprint(\"Top 10 States by AI Job Growth:\")\nprint(avg_growth_state[avg_growth_state[\"AI_JOB\"] == \"AI\"].head(10))\n\nprint(\"\\nTop 10 States by Non-AI Job Growth:\")\nprint(avg_growth_state[avg_growth_state[\"AI_JOB\"] == \"Non-AI\"].head(10))\n\nprint(\"Top 10 Cities by AI Job Growth:\")\nprint(avg_growth_city[avg_growth_city[\"AI_JOB\"] == \"AI\"].head(10))\n\nprint(\"\\nTop 10 Cities by Non-AI Job Growth:\")\nprint(avg_growth_city[avg_growth_city[\"AI_JOB\"] == \"Non-AI\"].head(10))\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nstate_visual = avg_growth_state.groupby(\"AI_JOB\").head(10)\n\nplt.figure(figsize=(10,6))\nax_state = sns.barplot(data=state_visual, y=\"STATE_NAME\", x=\"GROWTH\", hue=\"AI_JOB\", palette=\"viridis\")\nplt.title(\"Top 10 States by Average Monthly Job Growth: AI vs Non-AI\")\nplt.xlabel(\"Average Monthly Growth (%)\")\nplt.ylabel(\"State\")\n\nfor container in ax_state.containers:\n  ax_state.bar_label(container, fmt=\"%.1f%%\", label_type=\"edge\", padding=3, fontsize=9)\n\nplt.tight_layout()\nplt.savefig(\"../ad688_group6_geographic_analysis/images/top10state.png\", dpi=300)\nplt.show()\n\ncity_visual = avg_growth_city.groupby(\"AI_JOB\").head(10)\n\nplt.figure(figsize=(10,6))\nax_city = sns.barplot(data=city_visual, y=\"CITY_NAME\", x=\"GROWTH\", hue=\"AI_JOB\", palette=\"viridis\")\nplt.title(\"Top 10 Cities by Average Monthly Job Growth: AI vs Non-AI\")\nplt.xlabel(\"Average Monthly Growth (%)\")\nplt.ylabel(\"City\")\n\nfor container in ax_city.containers:\n  ax_city.bar_label(container, fmt=\"%.1f%%\", label_type=\"edge\", padding=3, fontsize=9)\n\nplt.tight_layout()\nplt.savefig(\"../ad688_group6_geographic_analysis/images/top10city.png\", dpi=300)\nplt.show()\n\n\n```\n\n## Key Insights\n\nThe analysis shows that AI jobs postings are increasing at a higher rate than Non-AI jobs, and that is especially true in Hawaii, Wyoming, Montana, and Mississippi. However, there seems to be no AI Job growth in multiple states, and an increase in Non-AI jobs in those same states, suggesting that AI isn't quite yet displacing jobs. In fact, there are only a select few states where AI Jobs are increasing, most of the 50 states have an increase in Non-AI jobs.\n\n# Remote Job Growth by Industry\n\nKey Insights: \n```{python}\n#Question 2: Are remote jobs increasing or decreasing across industries?\n\nremote_only = clean_pdf[clean_pdf[\"REMOTE_TYPE_NAME\"] == \"Remote\"]\n\nremote_growth = (\n  remote_only.groupby([\"NAICS_2022_2_NAME\", \"POSTED_MONTH\"])\n  .size()\n  .reset_index(name=\"count\")\n)\n\n\ntop_5_industries = (\n  remote_only[\"NAICS_2022_2_NAME\"]\n  .value_counts()\n  .head(5)\n  .index\n)\n\ntop_remote_growth = remote_growth[remote_growth[\"NAICS_2022_2_NAME\"].isin(top_5_industries)]\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(12, 7))\nsns.lineplot(\n    data=top_remote_growth,\n    x=\"POSTED_MONTH\",\n    y=\"count\",\n    hue=\"NAICS_2022_2_NAME\"\n)\nplt.title(\"Remote Job Trends Across Top 10 Industries\")\nplt.xlabel(\"Month\")\nplt.ylabel(\"Number of Job Postings\")\nplt.legend(title=\"Industry\", bbox_to_anchor=(1.05, 1), loc='upper left')\nplt.tight_layout()\nplt.savefig(\"../ad688_group6_geographic_analysis/images/remoteindustries.png\", dpi=300)\nplt.show()\n\n```\n\n## Key Insights\n\nWhen looking at the growth of Remote jobs by industry, we can see that there is an increase in remote jobs in the Finance and Insurance Industries, the Information Industries, and the Administrative and Support and Waste Management and Remediation Services Industries. This seems to suggest that more tech heavy industries can support and are seeing growth in remote positions, but industries like Professional, Scientific, and Technical Services are actually seeing a decline in remote work. These industries might have job titles that require in person work and assistance, which would lead to on-site.\n\n# Tech-Hubs vs emerging Markets\n\nKey Insights: \n```{python}\n#Question #3: Do Tech hubs (Silicon Valley, Austin, Boston) still dominate hiring, or are other locations emerging?\n\ntech_hubs = [\"Austin-Round Rock-Georgetown, TX\", \"Boston-Cambridge-Newton, MA-NH\",\"Los Angeles-Long Beach-Anaheim, CA\",\"San Diego-Chula Vista-Carlsbad, CA\",\"San Francisco-Oakland-Berkeley, CA\",\"San Jose-Sunnyvale-Santa Clara, CA\",\"Seattle-Tacoma-Bellevue, WA\"]\n\n# Create a column classifying if the city is a tech hub\nclean_pdf[\"TECH_HUB\"] = clean_pdf[\"MSA_NAME\"].apply(\n    lambda x: \"Tech Hub\" if x in tech_hubs else \"Other\"\n)\n\n#Count number of postings by Tech Hub\ntech_hub_counts = (\n  clean_pdf.groupby(\"MSA_NAME\")\n  .size()\n  .reset_index(name=\"count\")\n  .sort_values(\"count\", ascending=False)\n)\n\n# Merge to add TECH_HUB classification to each MSA\ntech_hub_counts = tech_hub_counts.merge(\n    clean_pdf[[\"MSA_NAME\", \"TECH_HUB\"]].drop_duplicates(),\n    on=\"MSA_NAME\",\n    how=\"left\"\n)\n\n\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nplt.figure(figsize=(18, 15))\nsns.barplot(\n    data=tech_hub_counts.head(15),\n    x=\"MSA_NAME\",\n    y=\"count\",\n    hue=\"TECH_HUB\",\n    palette=\"viridis\"\n)\nplt.title(\"Top 15 Metro Areas by Count of Job Postings\")\nplt.xlabel(\"Tech Hub\")\nplt.ylabel(\"Number of Job Postings\")\nplt.xticks(rotation=45, ha=\"right\")\n\n# Add labels on top of bars\n#for i, row in tech_hub_counts.head(15).iterrows():\n#    plt.text(row[\"count\"] + 100, i, f\"{row['count']:,}\", va=\"center\", fontsize=10)\n\n#plt.tight_layout()\nplt.savefig(\"../ad688_group6_geographic_analysis/images/top15techhubs.png\", dpi=300)\nplt.show()\n\n```\n![Top 15 Tech Hubs](../ad688_group6_geographic_analysis/images/top15techhubs.png){fig-align=\"center\" width=\"80%\"}\n\n## Key Insights\n\nThis plot is showing the concentration of job postings in each of the top 15 metro areas, which is interesting because the top 5 are actually not part of the tech hubs list that we created. Number 6, 7, 8, 11, and 15 are tech hubs, but this goes to show that a job seeker does not need to be in a tech hub for job searching. There are plenty of high population, metro areas that will have plenty of jobs. We would like to go further and look at industry and AI jobs as well, which is found in the next plot.\n\n# A Comparison of the Urban and Rural Job Market in relation to AI Careers\n\nKey Insights: \n```{python}\n# Question 4: How do Urban vs. Rural Job markets differ for AI and non-AI careers?\n\n# Classify as 'Urban' if MSA_NAME is present, else 'Rural'\nclean_pdf[\"URBAN_RURAL\"] = clean_pdf[\"MSA_NAME\"].apply(lambda x: \"Urban\" if pd.notnull(x) else \"Rural\")\n\n# Group data by month, urban/rural, and AI vs Non-AI\nurban_rural_jobs = (\n    clean_pdf.groupby([\"URBAN_RURAL\", \"AI_JOB\"])\n    .size()\n    .reset_index(name=\"count\")\n)\n\n#Calculate percentages\nurban_rural_jobs[\"PERCENT\"] = (\n  urban_rural_jobs.groupby(\"URBAN_RURAL\")[\"count\"]\n  .apply(lambda x: 100 * x / x.sum())\n  .values\n)\n\n#Convert Percentage into 2 decimal places\n\nurban_rural_jobs[\"PERCENT\"] = urban_rural_jobs[\"PERCENT\"].apply(lambda x:f\"{x:.2f}%\")\n\n# Visualization\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(12, 6))\nax_urban = sns.barplot(\n    data=urban_rural_jobs,\n    x=\"URBAN_RURAL\",\n    y=\"count\",\n    hue=\"AI_JOB\",\n    palette=\"viridis\"\n)\n\nplt.title(\"AI vs Non-AI Jobs in Urban vs Rural Areas\")\nplt.xlabel(\"Urban or Rural\")\nplt.ylabel(\"Number of Job Postings\")\nplt.legend(title=\"Job Type\")\n\nfor container in ax_urban.containers:\n  ax_urban.bar_label(container, fmt=\"%d\", label_type=\"edge\", padding=3, fontsize=11)\nplt.tight_layout()\nplt.savefig(\"../ad688_group6_geographic_analysis/images/urbanai.png\", dpi=300)\nplt.show()\n\nfig, ax = plt.subplots(figsize=(7,4))  \nax.axis('off') \n\ntable = ax.table(\n    cellText=urban_rural_jobs.values,\n    colLabels=urban_rural_jobs.columns,\n    cellLoc='center',\n    loc='center',\n    colColours=[\"#0b2545\"]*len(urban_rural_jobs.columns),  # Dark blue header\n    colWidths=[0.3]*len(urban_rural_jobs.columns)\n)\n\ntable.auto_set_font_size(False)\ntable.set_fontsize(12)\ntable.scale(1.2, 1.2) \n\nfor key, cell in table.get_celld().items():\n  if key[0] == 0:\n    cell.set_fontsize(14)\n    cell.set_text_props(color='white')\n    cell.set_facecolor('#0b2545')\n\nplt.show()\n\n```\n\n## Key Insights\n\nThis plot shows that the percentage of AI Jobs in Urban areas is actually almost exactly equal to the percentage of AI Jobs in rural areas. Even though the count of these types of jobs are much different, there are opportunities for job seekers to find AI related jobs at the same rate in rural areas compared to urban areas."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"kernal":"python3","keep-session":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"number-sections":true,"output-file":"data_analysis.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.34","theme":["cosmo","brand"],"title":"Data Analysis","subtitle":"Comprehensive Data Cleaning & Exploratory Analysis of Geographic Data","author":["Dakota Alder","Julio Garcia"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}