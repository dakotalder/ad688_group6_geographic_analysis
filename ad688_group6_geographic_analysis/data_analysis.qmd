---
title: "Data Analysis"
subtitle: "Comprehensive Data Cleaning & Exploratory Analysis of Geographic Data"
author:
  - name: Dakota Alder
    affiliations:
      - id: bu
        name: Boston University
        city: Boston
        state: MA
  - name: Julio Garcia
    affiliations:
      - id: bu
        name: Boston University
        city: Boston
        state: MA
#bibliography: references.bib
#csl: csl/econometrica.csl
format: 
  html:
    toc: true
    number-sections: true
    df-print: paged
---


```{python}
from pyspark.sql import SparkSession


# Start a Spark session
spark = SparkSession.builder.appName("JobPostingsAnalysis").getOrCreate()

# Load the CSV file into a Spark DataFrame
df = spark.read.option("header", "true").option("inferSchema", "true").option("multiLine","true").option("escape", "\"").csv("../data/lightcast_job_postings.csv")

# Register the DataFrame as a temporary SQL view
df.createOrReplaceTempView("project_data")


```

```{python}
import pandas as pd
from pyspark.sql.functions import when, col

#Clean Data to convert to Pandas
columns_to_drop = ["ID", "BODY", "URL", "ACTIVE_URLS", "DUPLICATES", "LAST_UPDATED_TIMESTAMP",
    "NAICS2", "NAICS3", "NAICS4", "NAICS5", "NAICS6",
    "SOC_2", "SOC_3", "SOC_4", "SOC_5", "LAST_UPDATED_DATE", "LAST_UPDATED_TIMESTAMP", "EXPIRED", "SOURCE_TYPES", "SOURCES", "ACTIVE_SOURCES_INFO", "MODELED_EXPIRED", "MODELED_DURATION", "NAICS2_NAME", "NAICS3_NAME", "NAICS4_NAME", "NAICS5_NAME", "NAICS6_NAME",
    "SOC_2_NAME", "SOC_3_NAME", "SOC_4_NAME", "SOC_5_NAME", "EDUCATION_LEVELS", "MIN_EDULEVELS"
    
]
cleaned_data = df.drop(*columns_to_drop)

cleaned_data = cleaned_data.withColumn(
    "REMOTE_TYPE_NAME",
    when(col("REMOTE_TYPE_NAME") == "Remote", "Remote")
    .when(col("REMOTE_TYPE_NAME") == "Hybrid Remote", "Hybrid")
    .when(col("REMOTE_TYPE_NAME") == "[None]", "On-site")
    .when(col("REMOTE_TYPE_NAME").isNull(), "On-site")
    .when(col("REMOTE_TYPE_NAME") == "Not Remote", "On-site")
    .otherwise(col("REMOTE_TYPE_NAME"))
)

cleaned_data = cleaned_data.withColumn(
    "EMPLOYMENT_TYPE_NAME",
    when(col("EMPLOYMENT_TYPE_NAME") == "Part-time / full-time", "Flexible")
    .when(col("EMPLOYMENT_TYPE_NAME").isNull(), "Full-Time")
    .when(col("EMPLOYMENT_TYPE_NAME") == "Part-time (â‰¤ 32 hours)", "Part-Time")
    .when(col("EMPLOYMENT_TYPE_NAME") == "Full-time (> 32 hours)", "Full-Time")
    .otherwise(col("EMPLOYMENT_TYPE_NAME")) 
)

cleaned_data = cleaned_data.filter(col("NAICS_2022_2_NAME") != "Unclassified Industry")

median_salary = cleaned_data.approxQuantile("SALARY", [0.5], 0.01)[0]
cleaned_data = cleaned_data.withColumn(
    "SALARY",
    when(col("SALARY").isNull(), median_salary).otherwise(col("SALARY"))
)


clean_pdf = cleaned_data.toPandas()



```

```{python}
#| echo: true
#| eval: true
import missingno as msno
import matplotlib.pyplot as plt

# Visualize missing data
msno.heatmap(clean_pdf)
plt.title("Missing Values Heatmap")
plt.show()

fill_cols = ["CITY_NAME", "CITY", "LOCATION", "STATE", "STATE_NAME", "COMPANY", "COMPANY_NAME"]
clean_pdf[fill_cols] = clean_pdf[fill_cols].fillna("Unknown")

clean_pdf = clean_pdf.drop_duplicates(subset=["TITLE", "COMPANY", "LOCATION", "POSTED"], keep="first")

clean_pdf.dropna(thresh=len(clean_pdf)*0.5, axis=1, inplace=True)


```

```{python}
#New Column to Classify AI Jobs and Add Month of Posting Date


ai_keywords = [
    "AI", "Machine Learning", "Data Scientist", "Data Analyst", "ML", 
    "Artificial Intelligence", "Deep Learning", "NLP", "Predictive Analytics"
]

#Function to classify AI vs Non-AI Jobs
def classify_ai(title):
    title_lower = str(title).lower()
    for keyword in ai_keywords:
        if keyword.lower() in title_lower:
            return "AI"
    return "Non-AI"

clean_pdf["AI_JOB"] = clean_pdf["TITLE_RAW"].apply(classify_ai)

clean_pdf["POSTED"] = pd.to_datetime(clean_pdf["POSTED"], errors="coerce")
clean_pdf["POSTED_MONTH"] = clean_pdf["POSTED"].dt.month

clean_pdf.head(25)
```


```{python}
#Question 1 Visualization: Which Cities or States have the highest job growth for AI vs Non-AI

count_by_month_state = (
  clean_pdf.groupby(["STATE_NAME", "POSTED_MONTH", "AI_JOB"])
  .size()
  .reset_index(name="count")
)

count_by_month_city = (
  clean_pdf.groupby(["CITY_NAME", "POSTED_MONTH", "AI_JOB"])
  .size()
  .reset_index(name="count")
)

#Measure job growth by State and then by city
count_by_month_state = count_by_month_state.sort_values(["STATE_NAME", "AI_JOB", "POSTED_MONTH"])
count_by_month_state["GROWTH"] = (
  count_by_month_state
  .groupby(["STATE_NAME", "AI_JOB"])["count"]
  .pct_change() * 100
)

count_by_month_city = count_by_month_city.sort_values(["CITY_NAME", "AI_JOB", "POSTED_MONTH"])
count_by_month_city["GROWTH"] = (
  count_by_month_city
  .groupby(["CITY_NAME", "AI_JOB"])["count"]
  .pct_change() * 100
)

avg_growth_state = (
    count_by_month_state.groupby(["STATE_NAME", "AI_JOB"])["GROWTH"]
    .mean()
    .reset_index()
    .dropna()
    .sort_values("GROWTH", ascending=False)
)

avg_growth_city = (
    count_by_month_city.groupby(["CITY_NAME", "AI_JOB"])["GROWTH"]
    .mean()
    .reset_index()
    .dropna()
    .sort_values("GROWTH", ascending=False)
)

print("Top 10 States by AI Job Growth:")
print(avg_growth_state[avg_growth_state["AI_JOB"] == "AI"].head(10))

print("\nTop 10 States by Non-AI Job Growth:")
print(avg_growth_state[avg_growth_state["AI_JOB"] == "Non-AI"].head(10))

print("Top 10 Cities by AI Job Growth:")
print(avg_growth_city[avg_growth_city["AI_JOB"] == "AI"].head(10))

print("\nTop 10 Cities by Non-AI Job Growth:")
print(avg_growth_city[avg_growth_city["AI_JOB"] == "Non-AI"].head(10))

import matplotlib.pyplot as plt
import seaborn as sns

state_visual = avg_growth_state.groupby("AI_JOB").head(10)

plt.figure(figsize=(10,6))
ax_state = sns.barplot(data=state_visual, y="STATE_NAME", x="GROWTH", hue="AI_JOB")
plt.title("Top 10 States by Average Monthly Job Growth: AI vs Non-AI")
plt.xlabel("Average Monthly Growth (%)")
plt.ylabel("State")

for container in ax_state.containers:
  ax_state.bar_label(container, fmt="%.1f%%", label_type="edge", padding=3, fontsize=9)

plt.tight_layout()
plt.show()

city_visual = avg_growth_city.groupby("AI_JOB").head(10)

plt.figure(figsize=(10,6))
ax_city = sns.barplot(data=city_visual, y="CITY_NAME", x="GROWTH", hue="AI_JOB")
plt.title("Top 10 Cities by Average Monthly Job Growth: AI vs Non-AI")
plt.xlabel("Average Monthly Growth (%)")
plt.ylabel("City")

for container in ax_city.containers:
  ax_city.bar_label(container, fmt="%.1f%%", label_type="edge", padding=3, fontsize=9)

plt.tight_layout()
plt.show()


```

```{python}
#Question 2: Are remote jobs increasing or decreasing across industries?

remote_only = clean_pdf[clean_pdf["REMOTE_TYPE_NAME"] == "Remote"]

remote_growth = (
  remote_only.groupby(["NAICS_2022_2_NAME", "POSTED_MONTH"])
  .size()
  .reset_index(name="count")
)


top_5_industries = (
  remote_only["NAICS_2022_2_NAME"]
  .value_counts()
  .head(5)
  .index
)

top_remote_growth = remote_growth[remote_growth["NAICS_2022_2_NAME"].isin(top_5_industries)]

import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(12, 7))
sns.lineplot(
    data=top_remote_growth,
    x="POSTED_MONTH",
    y="count",
    hue="NAICS_2022_2_NAME"
)
plt.title("Remote Job Trends Across Top 10 Industries")
plt.xlabel("Month")
plt.ylabel("Number of Job Postings")
plt.legend(title="Industry", bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

```

```{python}
#Question #3: Do Tech hubs (Silicon Valley, Austin, Boston) still dominate hiring, or are other locations emerging?

tech_hubs = ["Austin-Round Rock-Georgetown, TX", "Boston-Cambridge-Newton, MA-NH","Los Angeles-Long Beach-Anaheim, CA","San Diego-Chula Vista-Carlsbad, CA","San Francisco-Oakland-Berkeley, CA","San Jose-Sunnyvale-Santa Clara, CA","Seattle-Tacoma-Bellevue, WA"]

# Create a column classifying if the city is a tech hub
clean_pdf["TECH_HUB"] = clean_pdf["MSA_NAME"].apply(
    lambda x: "Tech Hub" if x in tech_hubs else "Other"
)

#Count number of postings by Tech Hub
tech_hub_counts = (
  clean_pdf.groupby("MSA_NAME")
  .size()
  .reset_index(name="count")
  .sort_values("count", ascending=False)
)

# Merge to add TECH_HUB classification to each MSA
tech_hub_counts = tech_hub_counts.merge(
    clean_pdf[["MSA_NAME", "TECH_HUB"]].drop_duplicates(),
    on="MSA_NAME",
    how="left"
)


import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(12, 8))
sns.barplot(
    data=tech_hub_counts.head(15),
    x="MSA_NAME",
    y="count",
    hue="TECH_HUB",
    palette="viridis"
)
plt.title("Top 15 Metro Areas by Count of Job Postings")
plt.xlabel("Tech Hub")
plt.ylabel("Number of Job Postings")
plt.xticks(rotation=60, ha="right")

# Add labels on top of bars
for i, row in tech_hub_counts.head(15).iterrows():
    plt.text(row["count"] + 100, i, f"{row['count']:,}", va="center", fontsize=10)

plt.tight_layout()
plt.show()

 



```

```{python}
# Question 4: How do Urban vs. Rural Job markets differ for AI and non-AI careers?

# Classify as 'Urban' if MSA_NAME is present, else 'Rural'
clean_pdf["URBAN_RURAL"] = clean_pdf["MSA_NAME"].apply(lambda x: "Urban" if pd.notnull(x) else "Rural")

# Group data by month, urban/rural, and AI vs Non-AI
urban_rural_jobs = (
    clean_pdf.groupby(["URBAN_RURAL", "AI_JOB"])
    .size()
    .reset_index(name="count")
)

#Calculate percentages
urban_rural_jobs["PERCENT"] = (
  urban_rural_jobs.groupby("URBAN_RURAL")["count"]
  .apply(lambda x: 100 * x / x.sum())
  .values
)

#Convert Percentage into 2 decimal places

urban_rural_jobs["PERCENT"] = urban_rural_jobs["PERCENT"].apply(lambda x:f"{x:.2f}%")

# Visualization
import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(12, 6))
ax_urban = sns.barplot(
    data=urban_rural_jobs,
    x="URBAN_RURAL",
    y="count",
    hue="AI_JOB",
    palette="viridis"
)

plt.title("AI vs Non-AI Jobs in Urban vs Rural Areas")
plt.xlabel("Urban or Rural")
plt.ylabel("Number of Job Postings")
plt.legend(title="Job Type")

for container in ax_urban.containers:
  ax_urban.bar_label(container, fmt="%d", label_type="edge", padding=3, fontsize=11)
plt.tight_layout()
plt.show()

fig, ax = plt.subplots(figsize=(7,4))  
ax.axis('off') 

table = ax.table(
    cellText=urban_rural_jobs.values,
    colLabels=urban_rural_jobs.columns,
    cellLoc='center',
    loc='center',
    colColours=["#0b2545"]*len(urban_rural_jobs.columns),  # Dark blue header
    colWidths=[0.3]*len(urban_rural_jobs.columns)
)

table.auto_set_font_size(False)
table.set_fontsize(12)
table.scale(1.2, 1.2) 

for key, cell in table.get_celld().items():
  if key[0] == 0:
    cell.set_fontsize(14)
    cell.set_text_props(color='white')
    cell.set_facecolor('#0b2545')

plt.show()

```

