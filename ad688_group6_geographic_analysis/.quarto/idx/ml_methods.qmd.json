{"title":"Machine Learning Methods","markdown":{"yaml":{"title":"Machine Learning Methods","subtitle":"Regression, Classification, Topic Insights","author":["Dakota Alder","Julio Garcia"],"format":{"html":{"toc":true,"number-sections":true,"df-print":"paged"}}},"headingText":"Data Loading and Cleaning","containsRefs":false,"markdown":"\n\n```{python}\nfrom pyspark.sql import SparkSession\n\n# Start a Spark session\nspark = SparkSession.builder.appName(\"JobPostingsAnalysis\").getOrCreate()\n\n# Load the CSV file into a Spark DataFrame\ndf = spark.read.option(\"header\", \"true\").option(\"inferSchema\", \"true\").option(\"multiLine\",\"true\").option(\"escape\", \"\\\"\").csv(\"../data/lightcast_job_postings.csv\")\n\n\n\n```\n\n```{python}\nimport pandas as pd\nfrom pyspark.sql.functions import when, col\n\n#Clean Data to convert to Pandas\ncolumns_to_drop = [\"ID\", \"BODY\", \"URL\", \"ACTIVE_URLS\", \"DUPLICATES\", \"LAST_UPDATED_TIMESTAMP\",\n    \"NAICS2\", \"NAICS3\", \"NAICS4\", \"NAICS5\", \"NAICS6\",\n    \"SOC_2\", \"SOC_3\", \"SOC_4\", \"SOC_5\", \"LAST_UPDATED_DATE\", \"LAST_UPDATED_TIMESTAMP\", \"EXPIRED\", \"SOURCE_TYPES\", \"SOURCES\", \"ACTIVE_SOURCES_INFO\", \"MODELED_EXPIRED\", \"MODELED_DURATION\", \"NAICS2_NAME\", \"NAICS3_NAME\", \"NAICS4_NAME\", \"NAICS5_NAME\", \"NAICS6_NAME\",\n    \"SOC_2_NAME\", \"SOC_3_NAME\", \"SOC_4_NAME\", \"SOC_5_NAME\", \"EDUCATION_LEVELS\", \"MIN_EDULEVELS\"\n    \n]\ncleaned_data = df.drop(*columns_to_drop)\n\ncleaned_data = cleaned_data.withColumn(\n    \"REMOTE_TYPE_NAME\",\n    when(col(\"REMOTE_TYPE_NAME\") == \"Remote\", \"Remote\")\n    .when(col(\"REMOTE_TYPE_NAME\") == \"Hybrid Remote\", \"Hybrid\")\n    .when(col(\"REMOTE_TYPE_NAME\") == \"[None]\", \"On-site\")\n    .when(col(\"REMOTE_TYPE_NAME\").isNull(), \"On-site\")\n    .when(col(\"REMOTE_TYPE_NAME\") == \"Not Remote\", \"On-site\")\n    .otherwise(col(\"REMOTE_TYPE_NAME\"))\n)\n\ncleaned_data = cleaned_data.withColumn(\n    \"EMPLOYMENT_TYPE_NAME\",\n    when(col(\"EMPLOYMENT_TYPE_NAME\") == \"Part-time / full-time\", \"Flexible\")\n    .when(col(\"EMPLOYMENT_TYPE_NAME\").isNull(), \"Full-Time\")\n    .when(col(\"EMPLOYMENT_TYPE_NAME\") == \"Part-time (â‰¤ 32 hours)\", \"Part-Time\")\n    .when(col(\"EMPLOYMENT_TYPE_NAME\") == \"Full-time (> 32 hours)\", \"Full-Time\")\n    .otherwise(col(\"EMPLOYMENT_TYPE_NAME\")) \n)\n\ncleaned_data = cleaned_data.filter(col(\"NAICS_2022_2_NAME\") != \"Unclassified Industry\")\n\nmedian_salary = cleaned_data.approxQuantile(\"SALARY\", [0.5], 0.01)[0]\ncleaned_data = cleaned_data.withColumn(\n    \"SALARY\",\n    when(col(\"SALARY\").isNull(), median_salary).otherwise(col(\"SALARY\"))\n)\n\n#Convert to Pandas\nclean_pdf = cleaned_data.toPandas()\n\n\n```\n\n```{python}\n#| echo: true\n#| eval: true\n# Cleaning empty rows and dropping columns that are mostly empty\n\n\nfill_cols = [\"CITY_NAME\", \"CITY\", \"LOCATION\", \"STATE\", \"STATE_NAME\", \"COMPANY\", \"COMPANY_NAME\"]\nclean_pdf[fill_cols] = clean_pdf[fill_cols].fillna(\"Unknown\")\n\nclean_pdf = clean_pdf.drop_duplicates(subset=[\"TITLE\", \"COMPANY\", \"LOCATION\", \"POSTED\"], keep=\"first\")\n\nclean_pdf.dropna(thresh=len(clean_pdf)*0.5, axis=1, inplace=True)\n\n#New Column to Classify AI Jobs and Add Month of Posting Date\n\nai_keywords = [\n    \"AI\", \"Machine Learning\", \"Data Scientist\", \"Data Analyst\", \"ML\", \n    \"Artificial Intelligence\", \"Deep Learning\", \"NLP\", \"Predictive Analytics\"\n]\n\n#Function to classify AI vs Non-AI Jobs\ndef classify_ai(title):\n    title_lower = str(title).lower()\n    for keyword in ai_keywords:\n        if keyword.lower() in title_lower:\n            return \"AI\"\n    return \"Non-AI\"\n\nclean_pdf[\"AI_JOB\"] = clean_pdf[\"TITLE_RAW\"].apply(classify_ai)\n\nclean_pdf[\"POSTED\"] = pd.to_datetime(clean_pdf[\"POSTED\"], errors=\"coerce\")\nclean_pdf[\"POSTED_MONTH\"] = clean_pdf[\"POSTED\"].dt.month\n\n#Add column for URBAN vs RURAL\n\nclean_pdf[\"URBAN_RURAL\"] = clean_pdf[\"MSA_NAME\"].apply(lambda x: \"Urban\" if pd.notnull(x) else \"Rural\")\n\n```\n\n# Model 1: KMeans Clustering \n\nWe applied KMeans clustering to identify patterns in the data. We wanted to each cluster to represent a group of jobs based on characteristics of Salary, AI jobs, remote work, and Urban or Rural locations. We used an elbow method to find the ideal number of clusters, which was 4, though the model didn't reflect as concise groupings as wanted.\n\n**Features:**  \n\nSALARY: Continuous numerical feature to reflect compensation.  \nAI_JOB: Binary feature (AI vs Non-AI), one-hot encoded.  \nREMOTE_TYPE_NAME: One-hot encoded categories (On-site, Remote, Hybrid).  \nURBAN_RURAL: One-hot encoded (Urban or Rural).\n\n**Implications for Job Seekers**  \n\nA job seeker can use this model to see what type of characteristics of a job might be tied to others. For example, AI jobs might yield high salaries, and if we used a reference of industry might be able to find an industry of interest that falls in a cluster that is being regarded in the job hunt. This can also be tied into the Skills Gap Analysis to see what a job seeker should work on in order to be considered for a certain cluster.\n\n\n```{python}\n#KMeans clustering using NAICS as a reference but not a target\n\nfrom sklearn.preprocessing import StandardScaler\n\n# Select features\nfeatures = clean_pdf[[\"SALARY\", \"AI_JOB\", \"REMOTE_TYPE_NAME\", \"URBAN_RURAL\"]]\n\n# One-hot encode categorical columns\nfeatures_encoded = pd.get_dummies(features, columns=[\"AI_JOB\", \"REMOTE_TYPE_NAME\", \"URBAN_RURAL\"], drop_first=True)\n\n# Standardize numerical features (important for KMeans)\nscaler = StandardScaler()\nfeatures_scaled = scaler.fit_transform(features_encoded)\n\nfrom sklearn.cluster import KMeans\n\nk = 4\nkmeans = KMeans(n_clusters=k, random_state=42)\nclean_pdf[\"CLUSTER\"] = kmeans.fit_predict(features_scaled)\n\n#Use Industry Name (NAICS2022) as a reference label\n\ncluster_summary = (\n    clean_pdf.groupby([\"CLUSTER\", \"NAICS_2022_2_NAME\"])\n    .size()\n    .reset_index(name=\"count\")\n    .sort_values([\"CLUSTER\", \"count\"], ascending=[True, False])\n)\n\nprint(cluster_summary)\n\n#Used an Elbow Method to choose the correct number of clusters\n\nfrom sklearn.cluster import KMeans\nimport matplotlib.pyplot as plt\n\n# Example features\nX = features_encoded.values  # your numerical features\n\nwcss = []\nfor k in range(1, 15):\n    km = KMeans(n_clusters=k, random_state=42)\n    km.fit(X)\n    wcss.append(km.inertia_)\n\nplt.plot(range(1, 15), wcss, marker='o')\nplt.xlabel('Number of Clusters (k)')\nplt.ylabel('WCSS (Inertia)')\nplt.title('Elbow Method')\nplt.show()\n\ncluster_summary.head(20)  # Show top 20 to see patterns\n\none_hot_cols = ['AI_JOB_Non-AI', 'REMOTE_TYPE_NAME_On-site', 'REMOTE_TYPE_NAME_Remote', 'URBAN_RURAL_Urban']\n\nclean_pdf = pd.concat([clean_pdf, features_encoded[one_hot_cols]], axis=1)\n\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(10,6))\nsns.scatterplot(\n    data=clean_pdf,\n    x='SALARY',\n    y='AI_JOB_Non-AI',  \n    hue='CLUSTER',\n    palette='viridis',\n    alpha=0.7\n)\nplt.title(\"KMeans Clustering: Salary vs AI Jobs\")\nplt.xlabel(\"Salary\")\nplt.ylabel(\"AI JOB (1=Non-AI, 0=AI)\")\nplt.legend(title=\"Cluster\")\nplt.tight_layout()\nplt.show()\n\n\n```\n\n```{python}\n#Visualizing the NAICS Industries in reference to each cluster\n\n\n\nimport matplotlib.pyplot as plt\n\n\ntop_industries = (\n    clean_pdf.groupby([\"CLUSTER\", \"NAICS_2022_6_NAME\"])\n    .size()\n    .reset_index(name=\"count\")\n)\n\ntop3 = top_industries.groupby(\"CLUSTER\").apply(lambda x: x.nlargest(3, \"count\")).reset_index(drop=True)\n\n\npivot_df = top3.pivot(index=\"CLUSTER\", columns=\"NAICS_2022_6_NAME\", values=\"count\").fillna(0)\n\nprint(pivot_df)\n\npivot_df.plot(kind='bar', stacked=True, figsize=(10,6), colormap=\"viridis\")  \n\nplt.title(\"Top 3 Industries per Cluster\")\nplt.xlabel(\"Cluster\")\nplt.ylabel(\"Number of Job Postings\")\nplt.legend(title=\"Industry\", bbox_to_anchor=(1.05, 1), loc='upper left')\nplt.tight_layout()\nplt.show()\n\n\n\n```\n\n\n## Key Insights\n\nOut of the 4 clusters, it seems like there are 3 fairly clear clusters and 1 that is more ambiguous.\n\nCluster 0: The ambiguous one, doesn't seem to have any groupings along AI, Non-AI, and Salary.  \nCluster 1: This is a group of higher salary paid positions, but are grouped regardless of AI vs Non-AI.  \nCluster 2: These seem to be low paying, AI jobs.  \nCluster 3: These seem to be low paying Non-AI jobs.  \n\n**Industry Relationship:**  \n\nIt seems that the industries don't have as much of a bearing on each cluster. For example, we thought that the high paying clusters would be more tech industry focused, but the low paying cluster also has a large amount of job openings in the same industries. This may mean that salaries are most likely influenced less by Industry and AI impact and influenced more by Skills, seniority, and education.\n\n\n# Model 2: Linear Regression for Salary Prediction\n\nWe ran a linear regression model to predict job salaries based on location, remote status, and urban/rural classification. It estimates/predicts how location and job type impact salary. It’s useful for identifying which factors contribute to higher salaries and preferred work type.\n\n**Features used:**  \n\nSTATE_NAME: One-hot encoded categorical variable representing each state.  \nREMOTE_TYPE_NAME: One-hot encoded (Remote, Hybrid, On-site).  \nURBAN_RURAL: One-hot encoded (Urban vs. Rural).  \nTarget variable: SALARY (numerical).  \n\n**Implications for job seekers:**  \n\nThe model reveals which locations and job types may pay more, which is probably the most important consideration for job seekers.\n\nFor example, remote AI jobs in urban hubs may offer higher salaries than non-AI roles in rural areas.\n\nLimitations: This model focuses only on geographic and job-type features, so salary effects of skills, experience, or certifications are not captured. As we show, geographical data is not a greate predictor or estimator in Salary. We assume that education levels, experience, and skills may be a better predictor.\n\n```{python}\n#Predicting Salaries based on Location Data through Linear Regression\n#*Decided to run it in Pandas with Scikit as it's already been converted and cleaned\n\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_error, r2_score\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nreg_data = clean_pdf[[\"SALARY\", \"STATE_NAME\", \"REMOTE_TYPE_NAME\", \"URBAN_RURAL\"]]\n\nX = pd.get_dummies(reg_data[[\"STATE_NAME\", \"REMOTE_TYPE_NAME\", \"URBAN_RURAL\"]], drop_first=True)\ny = reg_data[\"SALARY\"]\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.2, random_state=42)\n\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n\ny_pred = model.predict(X_test)\nrmse = np.sqrt(mean_squared_error(y_test, y_pred))\nr2 = r2_score(y_test, y_pred)\n\nprint(f\"Evaulation Metrics:\")\nprint(f\"RMSE: {rmse:,.2f}\")\nprint(f\"R2: {r2:.3f}\")\n\ndf_coef = pd.DataFrame({\n    \"Feature\": X.columns,\n    \"Coefficient\": model.coef_\n}).sort_values(by=\"Coefficient\", ascending=False)\n\nprint(\"\\nTop PositiveInfluences on Salary:\")\nprint(df_coef.head(10))\n\nprint(\"\\nTop Negative Influences on Salary:\")\nprint(df_coef.tail(10))\n\n\nplt.figure(figsize=(12,9))\nplt.scatter(y_test, y_pred, alpha=0.5)\nplt.xlabel(\"Actual Salary\")\nplt.ylabel(\"Predicted Salary\")\nplt.title(\"Predicted vs Actual Salaries\")\nplt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--')\nplt.tight_layout()\nplt.show()\n\n\n```\n\n## Key Insights\n\n**Evaulation Metrics:**  \nRMSE: 29,689.15   \nR2: 0.006  \n\nThese metrics are saying that our features are not very influential on the salary, meaning that there are most likely better predictors of Salary than geographical predictors. Like previously stated, things like seniority, education, and skills may be better predictors to higher or lower salaries.\n\nAnother insight that might be able to be used by a job seeker might be the highest and negative influencers on salary. Even though our model isn't great, it seems that we can deduce that seeking a job in Washington might yield a higher salary vs. the baseline salary, but seeking a job in New Mexico might yield a lower salary than the baseline.\n\n","srcMarkdownNoYaml":"\n\n# Data Loading and Cleaning\n```{python}\nfrom pyspark.sql import SparkSession\n\n# Start a Spark session\nspark = SparkSession.builder.appName(\"JobPostingsAnalysis\").getOrCreate()\n\n# Load the CSV file into a Spark DataFrame\ndf = spark.read.option(\"header\", \"true\").option(\"inferSchema\", \"true\").option(\"multiLine\",\"true\").option(\"escape\", \"\\\"\").csv(\"../data/lightcast_job_postings.csv\")\n\n\n\n```\n\n```{python}\nimport pandas as pd\nfrom pyspark.sql.functions import when, col\n\n#Clean Data to convert to Pandas\ncolumns_to_drop = [\"ID\", \"BODY\", \"URL\", \"ACTIVE_URLS\", \"DUPLICATES\", \"LAST_UPDATED_TIMESTAMP\",\n    \"NAICS2\", \"NAICS3\", \"NAICS4\", \"NAICS5\", \"NAICS6\",\n    \"SOC_2\", \"SOC_3\", \"SOC_4\", \"SOC_5\", \"LAST_UPDATED_DATE\", \"LAST_UPDATED_TIMESTAMP\", \"EXPIRED\", \"SOURCE_TYPES\", \"SOURCES\", \"ACTIVE_SOURCES_INFO\", \"MODELED_EXPIRED\", \"MODELED_DURATION\", \"NAICS2_NAME\", \"NAICS3_NAME\", \"NAICS4_NAME\", \"NAICS5_NAME\", \"NAICS6_NAME\",\n    \"SOC_2_NAME\", \"SOC_3_NAME\", \"SOC_4_NAME\", \"SOC_5_NAME\", \"EDUCATION_LEVELS\", \"MIN_EDULEVELS\"\n    \n]\ncleaned_data = df.drop(*columns_to_drop)\n\ncleaned_data = cleaned_data.withColumn(\n    \"REMOTE_TYPE_NAME\",\n    when(col(\"REMOTE_TYPE_NAME\") == \"Remote\", \"Remote\")\n    .when(col(\"REMOTE_TYPE_NAME\") == \"Hybrid Remote\", \"Hybrid\")\n    .when(col(\"REMOTE_TYPE_NAME\") == \"[None]\", \"On-site\")\n    .when(col(\"REMOTE_TYPE_NAME\").isNull(), \"On-site\")\n    .when(col(\"REMOTE_TYPE_NAME\") == \"Not Remote\", \"On-site\")\n    .otherwise(col(\"REMOTE_TYPE_NAME\"))\n)\n\ncleaned_data = cleaned_data.withColumn(\n    \"EMPLOYMENT_TYPE_NAME\",\n    when(col(\"EMPLOYMENT_TYPE_NAME\") == \"Part-time / full-time\", \"Flexible\")\n    .when(col(\"EMPLOYMENT_TYPE_NAME\").isNull(), \"Full-Time\")\n    .when(col(\"EMPLOYMENT_TYPE_NAME\") == \"Part-time (â‰¤ 32 hours)\", \"Part-Time\")\n    .when(col(\"EMPLOYMENT_TYPE_NAME\") == \"Full-time (> 32 hours)\", \"Full-Time\")\n    .otherwise(col(\"EMPLOYMENT_TYPE_NAME\")) \n)\n\ncleaned_data = cleaned_data.filter(col(\"NAICS_2022_2_NAME\") != \"Unclassified Industry\")\n\nmedian_salary = cleaned_data.approxQuantile(\"SALARY\", [0.5], 0.01)[0]\ncleaned_data = cleaned_data.withColumn(\n    \"SALARY\",\n    when(col(\"SALARY\").isNull(), median_salary).otherwise(col(\"SALARY\"))\n)\n\n#Convert to Pandas\nclean_pdf = cleaned_data.toPandas()\n\n\n```\n\n```{python}\n#| echo: true\n#| eval: true\n# Cleaning empty rows and dropping columns that are mostly empty\n\n\nfill_cols = [\"CITY_NAME\", \"CITY\", \"LOCATION\", \"STATE\", \"STATE_NAME\", \"COMPANY\", \"COMPANY_NAME\"]\nclean_pdf[fill_cols] = clean_pdf[fill_cols].fillna(\"Unknown\")\n\nclean_pdf = clean_pdf.drop_duplicates(subset=[\"TITLE\", \"COMPANY\", \"LOCATION\", \"POSTED\"], keep=\"first\")\n\nclean_pdf.dropna(thresh=len(clean_pdf)*0.5, axis=1, inplace=True)\n\n#New Column to Classify AI Jobs and Add Month of Posting Date\n\nai_keywords = [\n    \"AI\", \"Machine Learning\", \"Data Scientist\", \"Data Analyst\", \"ML\", \n    \"Artificial Intelligence\", \"Deep Learning\", \"NLP\", \"Predictive Analytics\"\n]\n\n#Function to classify AI vs Non-AI Jobs\ndef classify_ai(title):\n    title_lower = str(title).lower()\n    for keyword in ai_keywords:\n        if keyword.lower() in title_lower:\n            return \"AI\"\n    return \"Non-AI\"\n\nclean_pdf[\"AI_JOB\"] = clean_pdf[\"TITLE_RAW\"].apply(classify_ai)\n\nclean_pdf[\"POSTED\"] = pd.to_datetime(clean_pdf[\"POSTED\"], errors=\"coerce\")\nclean_pdf[\"POSTED_MONTH\"] = clean_pdf[\"POSTED\"].dt.month\n\n#Add column for URBAN vs RURAL\n\nclean_pdf[\"URBAN_RURAL\"] = clean_pdf[\"MSA_NAME\"].apply(lambda x: \"Urban\" if pd.notnull(x) else \"Rural\")\n\n```\n\n# Model 1: KMeans Clustering \n\nWe applied KMeans clustering to identify patterns in the data. We wanted to each cluster to represent a group of jobs based on characteristics of Salary, AI jobs, remote work, and Urban or Rural locations. We used an elbow method to find the ideal number of clusters, which was 4, though the model didn't reflect as concise groupings as wanted.\n\n**Features:**  \n\nSALARY: Continuous numerical feature to reflect compensation.  \nAI_JOB: Binary feature (AI vs Non-AI), one-hot encoded.  \nREMOTE_TYPE_NAME: One-hot encoded categories (On-site, Remote, Hybrid).  \nURBAN_RURAL: One-hot encoded (Urban or Rural).\n\n**Implications for Job Seekers**  \n\nA job seeker can use this model to see what type of characteristics of a job might be tied to others. For example, AI jobs might yield high salaries, and if we used a reference of industry might be able to find an industry of interest that falls in a cluster that is being regarded in the job hunt. This can also be tied into the Skills Gap Analysis to see what a job seeker should work on in order to be considered for a certain cluster.\n\n\n```{python}\n#KMeans clustering using NAICS as a reference but not a target\n\nfrom sklearn.preprocessing import StandardScaler\n\n# Select features\nfeatures = clean_pdf[[\"SALARY\", \"AI_JOB\", \"REMOTE_TYPE_NAME\", \"URBAN_RURAL\"]]\n\n# One-hot encode categorical columns\nfeatures_encoded = pd.get_dummies(features, columns=[\"AI_JOB\", \"REMOTE_TYPE_NAME\", \"URBAN_RURAL\"], drop_first=True)\n\n# Standardize numerical features (important for KMeans)\nscaler = StandardScaler()\nfeatures_scaled = scaler.fit_transform(features_encoded)\n\nfrom sklearn.cluster import KMeans\n\nk = 4\nkmeans = KMeans(n_clusters=k, random_state=42)\nclean_pdf[\"CLUSTER\"] = kmeans.fit_predict(features_scaled)\n\n#Use Industry Name (NAICS2022) as a reference label\n\ncluster_summary = (\n    clean_pdf.groupby([\"CLUSTER\", \"NAICS_2022_2_NAME\"])\n    .size()\n    .reset_index(name=\"count\")\n    .sort_values([\"CLUSTER\", \"count\"], ascending=[True, False])\n)\n\nprint(cluster_summary)\n\n#Used an Elbow Method to choose the correct number of clusters\n\nfrom sklearn.cluster import KMeans\nimport matplotlib.pyplot as plt\n\n# Example features\nX = features_encoded.values  # your numerical features\n\nwcss = []\nfor k in range(1, 15):\n    km = KMeans(n_clusters=k, random_state=42)\n    km.fit(X)\n    wcss.append(km.inertia_)\n\nplt.plot(range(1, 15), wcss, marker='o')\nplt.xlabel('Number of Clusters (k)')\nplt.ylabel('WCSS (Inertia)')\nplt.title('Elbow Method')\nplt.show()\n\ncluster_summary.head(20)  # Show top 20 to see patterns\n\none_hot_cols = ['AI_JOB_Non-AI', 'REMOTE_TYPE_NAME_On-site', 'REMOTE_TYPE_NAME_Remote', 'URBAN_RURAL_Urban']\n\nclean_pdf = pd.concat([clean_pdf, features_encoded[one_hot_cols]], axis=1)\n\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nplt.figure(figsize=(10,6))\nsns.scatterplot(\n    data=clean_pdf,\n    x='SALARY',\n    y='AI_JOB_Non-AI',  \n    hue='CLUSTER',\n    palette='viridis',\n    alpha=0.7\n)\nplt.title(\"KMeans Clustering: Salary vs AI Jobs\")\nplt.xlabel(\"Salary\")\nplt.ylabel(\"AI JOB (1=Non-AI, 0=AI)\")\nplt.legend(title=\"Cluster\")\nplt.tight_layout()\nplt.show()\n\n\n```\n\n```{python}\n#Visualizing the NAICS Industries in reference to each cluster\n\n\n\nimport matplotlib.pyplot as plt\n\n\ntop_industries = (\n    clean_pdf.groupby([\"CLUSTER\", \"NAICS_2022_6_NAME\"])\n    .size()\n    .reset_index(name=\"count\")\n)\n\ntop3 = top_industries.groupby(\"CLUSTER\").apply(lambda x: x.nlargest(3, \"count\")).reset_index(drop=True)\n\n\npivot_df = top3.pivot(index=\"CLUSTER\", columns=\"NAICS_2022_6_NAME\", values=\"count\").fillna(0)\n\nprint(pivot_df)\n\npivot_df.plot(kind='bar', stacked=True, figsize=(10,6), colormap=\"viridis\")  \n\nplt.title(\"Top 3 Industries per Cluster\")\nplt.xlabel(\"Cluster\")\nplt.ylabel(\"Number of Job Postings\")\nplt.legend(title=\"Industry\", bbox_to_anchor=(1.05, 1), loc='upper left')\nplt.tight_layout()\nplt.show()\n\n\n\n```\n\n\n## Key Insights\n\nOut of the 4 clusters, it seems like there are 3 fairly clear clusters and 1 that is more ambiguous.\n\nCluster 0: The ambiguous one, doesn't seem to have any groupings along AI, Non-AI, and Salary.  \nCluster 1: This is a group of higher salary paid positions, but are grouped regardless of AI vs Non-AI.  \nCluster 2: These seem to be low paying, AI jobs.  \nCluster 3: These seem to be low paying Non-AI jobs.  \n\n**Industry Relationship:**  \n\nIt seems that the industries don't have as much of a bearing on each cluster. For example, we thought that the high paying clusters would be more tech industry focused, but the low paying cluster also has a large amount of job openings in the same industries. This may mean that salaries are most likely influenced less by Industry and AI impact and influenced more by Skills, seniority, and education.\n\n\n# Model 2: Linear Regression for Salary Prediction\n\nWe ran a linear regression model to predict job salaries based on location, remote status, and urban/rural classification. It estimates/predicts how location and job type impact salary. It’s useful for identifying which factors contribute to higher salaries and preferred work type.\n\n**Features used:**  \n\nSTATE_NAME: One-hot encoded categorical variable representing each state.  \nREMOTE_TYPE_NAME: One-hot encoded (Remote, Hybrid, On-site).  \nURBAN_RURAL: One-hot encoded (Urban vs. Rural).  \nTarget variable: SALARY (numerical).  \n\n**Implications for job seekers:**  \n\nThe model reveals which locations and job types may pay more, which is probably the most important consideration for job seekers.\n\nFor example, remote AI jobs in urban hubs may offer higher salaries than non-AI roles in rural areas.\n\nLimitations: This model focuses only on geographic and job-type features, so salary effects of skills, experience, or certifications are not captured. As we show, geographical data is not a greate predictor or estimator in Salary. We assume that education levels, experience, and skills may be a better predictor.\n\n```{python}\n#Predicting Salaries based on Location Data through Linear Regression\n#*Decided to run it in Pandas with Scikit as it's already been converted and cleaned\n\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_error, r2_score\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nreg_data = clean_pdf[[\"SALARY\", \"STATE_NAME\", \"REMOTE_TYPE_NAME\", \"URBAN_RURAL\"]]\n\nX = pd.get_dummies(reg_data[[\"STATE_NAME\", \"REMOTE_TYPE_NAME\", \"URBAN_RURAL\"]], drop_first=True)\ny = reg_data[\"SALARY\"]\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.2, random_state=42)\n\nmodel = LinearRegression()\nmodel.fit(X_train, y_train)\n\ny_pred = model.predict(X_test)\nrmse = np.sqrt(mean_squared_error(y_test, y_pred))\nr2 = r2_score(y_test, y_pred)\n\nprint(f\"Evaulation Metrics:\")\nprint(f\"RMSE: {rmse:,.2f}\")\nprint(f\"R2: {r2:.3f}\")\n\ndf_coef = pd.DataFrame({\n    \"Feature\": X.columns,\n    \"Coefficient\": model.coef_\n}).sort_values(by=\"Coefficient\", ascending=False)\n\nprint(\"\\nTop PositiveInfluences on Salary:\")\nprint(df_coef.head(10))\n\nprint(\"\\nTop Negative Influences on Salary:\")\nprint(df_coef.tail(10))\n\n\nplt.figure(figsize=(12,9))\nplt.scatter(y_test, y_pred, alpha=0.5)\nplt.xlabel(\"Actual Salary\")\nplt.ylabel(\"Predicted Salary\")\nplt.title(\"Predicted vs Actual Salaries\")\nplt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'r--')\nplt.tight_layout()\nplt.show()\n\n\n```\n\n## Key Insights\n\n**Evaulation Metrics:**  \nRMSE: 29,689.15   \nR2: 0.006  \n\nThese metrics are saying that our features are not very influential on the salary, meaning that there are most likely better predictors of Salary than geographical predictors. Like previously stated, things like seniority, education, and skills may be better predictors to higher or lower salaries.\n\nAnother insight that might be able to be used by a job seeker might be the highest and negative influencers on salary. Even though our model isn't great, it seems that we can deduce that seeking a job in Washington might yield a higher salary vs. the baseline salary, but seeking a job in New Mexico might yield a lower salary than the baseline.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":true,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"kernal":"python3","keep-session":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"number-sections":true,"output-file":"ml_methods.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.34","theme":["cosmo","brand"],"title":"Machine Learning Methods","subtitle":"Regression, Classification, Topic Insights","author":["Dakota Alder","Julio Garcia"]},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html","docx"]}